# 다음 문제입니다.
#
# 본 태스크에서는 디지털 시계에서 관찰될 수 있는 흥미로운 패턴에 대해 가정해 보겠습니다. 이 시계가 각 두 자리의 시:분:초 ("HH:MM:SS") 포맷으로 시각을 보여준다고 했을 때,
# * "HH"는 당일의 시간을 (00~23 사이에서) 두 자리로 표시
# * "MM"는 1시간 내의 분 수를 (00~59 사이에서) 두 자리로 표시
# * "SS"는 1분 내의 초 수를 (00~59 사이에서) 두 자리로 표시
#
# 상기 시간,분,초는 항상 두 자리로 표시되며, 경우에 따라 앞자리가 0으로 표시되는 경우도 물론 있습니다.
#
# 위에서 흥미롭다고 표현한 점은, 디지털 시계가 이와 같은 형태로 시각을 표시하는 과정에서 두 종류의 숫자 만으로 시각을 표시할 수 있는 경우가 있을 것이라는 점입니다. 가령 `13:31:33`과 `:02:20:22`라는 시간이 있다고 한다면 첫 사례에서는 1과 3만을, 두 번째 사레에서는 0과 2만을 사용하여 시각이 표시되고 있습니다. 또 다른 흥미로운 형태의 시각 표현으로는 0만으로 표시한 시각인 `00:00:00`이 있을 수 있는 반면, `15:45:14`와 같은 시각은 세 종류의 숫자를 사용하여 시각을 표시하엿으므로 본 태스크에서의 관심사는 아닙니다.
#
# 구분자 `:`는 시각을 표시하는데 있어 상시적으로 표시되는 것이므로 숫자의 종류로 포함하여 간주하지는 않겠습니다.
#
# 본 태스크에서 여러분이 시행하여야 할 것은, 어느 주어진 시간 범위 내에서 이와 같이 두 종류의 숫자 이내로 표시되는 시각이 몇 개인지를 산출하는 것입니다.
# 아래와 같은 함수에서,
# `def solutions(S, T)`
# 스트링 S와 T가 각각 `HH:MM:SS` 포맷의 시각을 지칭한다고 했을 때, 이 함수의 리턴 값은 S시간과 T시간 사이의 시간 범위 (S와 T시간 포함) 사이에서 두 종류 이내의 숫자만을 사용하여 표시되는 시각의 개수가 되어야 합니다.
#
# 예제:
# 1. 가령, S와 T가 각각 `15:15:00`, `15:15:12` 라면, 두 시각 사이의 시간 범위에서 두 종류 이내의 숫자만을 사용하여 표시되는 시각은 `15:15:11` 하나뿐이므로 위 함수의 리턴 값은 1이 되어야 합니다.
# 2. 가령, S와 T가 각각 `22:22:21`, `22:22:23` 이라면, 위 함수의 리턴 값은 3(`22:22:21`, `22:22:22`, `22:22:23`)이 되어야 합니다.
#
# 다음과 같이 가정합니다:
# * 스트링 S와 T는 항상 시각 표시에 있어 `HH:MM:SS`포맷을 엄격히 준수.
# * 하루 중, 스트링 S는 T보다 항상 앞선 시각을 표시.

def solutions(S, T):
    # "HH:MM:SS" 형식의 시간을 초 단위로 변환하는 함수
    def time_to_seconds(time_str):
        h, m, s = map(int, time_str.split(':'))
        return h * 3600 + m * 60 + s

    # 초 단위를 "HH:MM:SS" 형식으로 변환하는 함수
    def seconds_to_time(seconds):
        h = seconds // 3600
        seconds %= 3600
        m = seconds // 60
        s = seconds % 60
        return f"{h:02}:{m:02}:{s:02}"

    # 시각이 두 가지 숫자만 사용된 경우인지 확인하는 함수
    def has_two_or_less_digits(time_str):
        digits = set(time_str.replace(':', ''))  # ':'를 제외하고 숫자만 확인
        return len(digits) <= 2  # 두 종류의 숫자 이하인지 확인

    # S와 T를 초 단위로 변환
    start_seconds = time_to_seconds(S)
    end_seconds = time_to_seconds(T)

    count = 0
    # S와 T 사이의 모든 시각을 확인
    for t in range(start_seconds, end_seconds + 1):
        current_time = seconds_to_time(t)
        if has_two_or_less_digits(current_time):
            count += 1

    return count

print(solutions("00:00:00","01:00:00"))
print(solutions("22:22:21", "22:22:23")) #ret=>3