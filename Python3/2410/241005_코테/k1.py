# 당신은 알고리즘 문제를 잘 푸는 파이썬 개발자입니다.
#
# N개의 구간(0부터 N-1까지 번호가 매겨짐)으로 이루어진 도로가 있습니다. 이 도로는 정수 배열 R로 설명됩니다. 가령, 이 도로 상의 K번째 세그먼트를 지칭할 때는 정수 R[K]로 설명됩니다. 해당 구간이 매끄럽다면 (R[K] = 0), 구간에는 포트홀이 없으며, 그렇지 않다면 R[K]는 포트홀의 깊이를 나타냅니다. 연속된 포트홀은 서로 연결되어 더 큰 포트홀 그룹을 형성합니다.
#
# 포트홀 인디케이터는 이와 같이 포트홀 그룹으로 묶인 연속 개별 포트홀의 개수와, 이들 개별 포트홀 중 가장 깊은 깊이값의 곱을 지칭합니다. 가령, 깊이값이 각각 [1,4,1]인 3개 개별 포트홀로 구성된 포트홀 그룹이 있다면, 그 포트홀 인디케이터 값은 3*4 = 12가 됩니다.
# 그렇다면 도로 전 구간에서 가장 높은 포트홀 인디케이터 값은 어떻게 구할 수 있을까요?
# 아래와 같은 함수에서.
# `def solution(R)`
#
# 이 정수배열이 N개 정수의 배열인 R이라고 할 때, 이 함수의 리턴 값은 가장 높은 포트홀 인디케이터 값이 됩니다.
#
# 예제:
# 1. R = [0,2,1,1,0,4,1]이라 할 때, 상기 함수의 리턴 값은 8입니다. 깊이 [2,1,1]의 각 개별 포트홀이 하나의 포트홀 그룹으로 묶인다고 했을 때, 이 포트홀 그룹은 3개 세그먼트로 구성되며 가장 깊은 깊이값은 2가 되므로 포트홀 인디케이터 값은 3 * 2 = 6가 됩니다. 깊이 [4,1]의 각 개별 포트홀이 하나의 포트홀 그룹으로 묶인다고 했을 때, 이 포트홀 그룹은 연속된 2개의 포트홀로 구성되며 가장 깊은 깊이값은 4이므로 포트홀 인디케이터 값은 2*4 = 8이 됩니다.
#
# 2. R = [1,4,1,0,5,2,3,0,8]이라 할 때, 상기 함수의 리턴 값은 15입니다. 여기서 각 3개의 포트홀 그룹이 아래와 같이 구성된다고 할 때,
# * [1,4,1]. 즉, 포트홀 인디케이터 값은 3* 4 = 12
# * [5,2,3]. 즉, 포트홀 인디케이터 값은 3 * 5 = 15
# * [8]. 즉, 포트홀 인디케이터 값은 1 * 8 = 8
# 가장 큰 포트홀 인디케이터 값은 15가 됩니다.
#
# 3. R = [9,8,7,0,0,0,2,3,6,4]이라 할 때, 상기 함수의 리턴 값은 27입니다. 여기서 각 2개의 포트홀 그룹이 아래와 같이 구성된다고 할 때,
# * [9,8,7]. 즉, 포트홀 인디케이터 값은 3* 9 = 27
# * [2,3,6,4]. 즉, 포트홀 인디케이터 값은 4 * 6 = 24
# 가장 큰 포트홀 인디케이터 값은 27이 됩니다.
#
# 4. R = [0,0,0]이라 할 때, 상기 함수의 리턴 값은 0입니다. 즉, 노상에 포트홀이 없는 경우로, 가장 높은 포트홀 인디케이터 값도 0 입니다.
#
# 다음 가정에 대한 효율적인 알고리즘을 작성하십시오:
# * N은 [1..100000] 범위의 정수입니다.
# * 배열 R의 각 요소는 [0..9] 범위 내의 정수입니다.

def solution(R):
    max_indicator = 0  # 가장 큰 포트홀 인디케이터 값을 저장하는 변수
    N = len(R)  # 배열의 길이
    i = 0  # 인덱스 초기화

    while i < N:
        if R[i] == 0:  # 포트홀이 없는 구간일 경우
            i += 1  # 다음 인덱스로 이동
            continue  # 다음 반복으로 넘어감

        # 포트홀 그룹의 시작
        group_size = 0  # 그룹 크기 초기화
        max_depth = 0  # 그룹 내 최대 깊이 초기화

        # 현재 그룹 탐색 (0이 나올 때까지 연속된 구간을 확인)
        while i < N and R[i] != 0:
            group_size += 1  # 그룹 크기를 늘림
            max_depth = max(max_depth, R[i])  # 최대 깊이 갱신
            i += 1  # 인덱스 증가

        # 현재 그룹의 포트홀 인디케이터 값 계산
        max_indicator = max(max_indicator, group_size * max_depth)

    return max_indicator


print(solution([0,2,1,1,0,4,1])) #-> 8
